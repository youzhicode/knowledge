# MySQL

### 常用数据类型：

### 数值类型：

| Type      | length              |
| --------- | ------------------- |
| TINYINT   | 1 byte              |
| SMALLINT  | 2 byte              |
| MEDIUMINT | 3 byte              |
| INT       | 4 byte              |
| BIGINT    | 8 byte              |
| FLOAT     | 4 byte              |
| DOUBLE    | 8 byte              |
| DECIMAL   | DECIMAL(m,n),,以来m和n |

### 字符类型

| CHAR       | 0~255 byte   | 定长字符串            |
| ---------- | ------------ | ---------------- |
| VARCHAR    | 0~65535 byte | 变长字符串            |
| TINYBLOB   | 0~255 byte   | 不超过255个字符的二进制字符串 |
| TINYTEXT   | 0~255 byte   | 超文本字符串           |
| BLOB       | 0~65535 byte | 二进制形式的文本数据       |
| TEXT       | 0~65535 byte | 长文本数据            |
| MEDIUMBLOB | 0~2**24-1    | 二进制的中等长度文本数据     |
| MEDIUMTEXT | 0~2**24-1    | 中等长度的文本数据        |
| LONGBLOB   | 0~2**32-1    | 二进制形式的极大文本数据     |
| LONGTEXT   | 0~2**32-1    | 极大文本数据           |

**PS: varchar(n), char(n) n表示的是字符数，不是字节**



### 日期和时间类型

| DATE      | 3 byte | 日期值            |
| --------- | ------ | -------------- |
| TIME      | 3 byte | 时间值            |
| YEAR      | 1 byte | 年份值            |
| DATETIME  | 8 byte | 混合日期和时间值       |
| TIMESTAMP | 4 byte | 混合日期和时间值的时间戳表示 |

**尽量使用TIMESTAMP 类型，空间利用率比较高



## 三大范式：

* 第一范式（1NF）：字段是不可分割的最小单元，既不会出现重复的列

* 第二范式（2NF）：满足1NF的前提下，存在一个候选码，所有非主属性都依赖该候选码。即存在主键，体现唯一性，专业术语就是消除部分函数依赖

* 第三范式（3NF）：满足2NF的前提下，非主属性必须互不依赖



### 范式和反范式

范式是满足某一级别的关系模式的集合。构造数据库必须遵循一定的规则，这些规则在数据库中就叫做范式

| 范式  | 符合范式化要求的表设计，数据冗余少，占用的存储空间少  | 因为没有数据冗余，经常需要连表查询，所以查询效率较低 |
| --- | --------------------------- | -------------------------- |
| 反范式 | 通过使用冗余数据，减少了连接查询，查询效率高，利于索引 | 存在大量的数据冗余，并且数据的维护成本更高      |

**个人习惯，先设计满足三大范式要求的表结构，然后再考虑反范式要求，以求达到一个折中**



## 索引

索引是对数据表中的一列或者多列的值进行重新排序的数据结构，用于快速访问数据表中的信息

### 索引的分类

#### 物理结构上可以分为：聚集索引 和 非聚集索引

聚集索引：索引的键值的逻辑顺序和相应行中的物理顺序一致。每张表只能有一个聚集索引，也就是我们常说的主键索引

非聚集索引：索引的键值逻辑顺序和物理行中的顺序不一致



#### 应用上划分

1. 普通索引：MySQL中的基本索引类型，没有什么限制，允许在定义索引的列中出现重复值和空值，目的就是为了提高查询速率

2. 唯一索引：索引列的值必须唯一，但是允许空值

3. 主键索引：特殊的唯一索引，不允许有空值，数据库系统自动帮我们创建

4. 组合索引：组合表中的多个字段创建索引，遵守最左前辍匹配规则

5. 全文索引：在MySQL中，只有MyISAM支持全文索引



### 索引设计规则

1. 选择唯一性索引：唯一性索引的值是唯一的，可以更快速的定位到该索引确定到要查找的记录

2. 为常作为查询条件的字段建立索引

3. 为经常排序，分组和联合操作的字段添加索引

4. 限制索引数目，合理的合计索引，并非越多越好，因为索引需要占据大量的空间，数据发生变更时也需要对索引做变更

5. 小表不建议创建索引

6. 删除不再使用的或者很少使用的索引

#### 索引的数据结构，哈希和B+

* Hash索引底层是hash table，进行查询时通过Hash 函数获取相应的键值，再回表查询获得相应的实际数据

* B+树，底层实现原理是多路平衡查找树，对于每一次查询都是从根节点出发，查询到叶子节点方可以获得所查找的键值，最后查询判断是否要会表查询



Hash索引的特点：

1. Hash进行等值查询的速度很快，但无法进行范围查询，因为经过hash函数建立的索引值，索引顺序和原顺序无法保持一致，故不能使用范围查询

2. Hash不支持模糊查询，因为Hash建立的索引值不可预测，也无任何规律

3. Hash任何时候都无法避免要回表

4. 虽然在等值查询上效率很高，但是如果在多重复值的情况下，会产生hash碰撞，效率反而减低

B+索引的特点：

1. B+树本身是一颗查找树，自然支持范围查找和排序

2. 在符合某些条件下（聚簇索引，覆盖索引）等情况下，不需要回表

3. 查询效率比较稳定，因为每次查询都是从根节点出发到叶子节点，且为树的高度

#### B+树和B树的区别：

* B树，叶子节点和非叶子节点都存储数据，B+树只有叶子节点存储数据

* B+树叶子节点通过链表相互连接，因此扫描叶子节点就可以完成一次遍历操作，而B树需要做中序遍历

#### 为什么B+树比B树更适合做索引

* B+树更加节省空间，一次加载进内存的数据更多，IO次数减少

* 查询效率更稳定

* B+更加适合范围查找，

#### 最左匹配规则：

最左优先，以最左边的起点任何连续所以都能匹配上，但是遇上范围查找就会停止匹配

#### 覆盖索引：

在B+树中，叶子节点可能存储了当前的键值，也可能存储了当前的键值和正行数据，这就是聚簇索引和非聚簇索引。在INNODB中，只有主键是聚簇索引，如果没有指定主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式生成一个键来建立聚簇索引。

当查询使用到了聚簇索引，叶子节点中保存了正行数据，因此不用回表查询



#### 什么是索引下推

- 索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。
- 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。
- 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。
- 索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

索引下推在**非主键索引**上的优化，可以有效减少回表的次数，大大提升了查询的效率。




